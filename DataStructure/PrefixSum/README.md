구간 합
===
기존의 배열을 전처리한 합 배열을 사용하여 시간 복잡도를 더 줄이기 위해 사용하는 특수한 목적의 알고리즘

아래는 구간 합의 사용 예시  
S는 합 배열, A는 기존 배열
```
S[5] = A[0] + A[1] + A[2] + A[3] + A[4] + A[5]
S[1] = A[0] + A[1]
S[5] - S[1] = A[2] + A[3] + A[4] + A[5]
```

# 11659 구간 합 구하기 1
```c++
#include <iostream>
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
    
	int suNo, quizNo;
	cin >> suNo >> quizNo;
	int S[100001] = {};

	for (int i = 1; i <= suNo; i++){
		int temp;
		cin >> temp;
		S[i] = S[i-1] + temp;	//구간합 구하기
	}
    // 위 반복문 실행 결과로 5,4,3,2,1을 입력받았을 때의 예시로 S는 [0,5,9,12,14,15]가 된다.
    // 예제 출력
    // 1 3 : 12
    // 2 4 : 9
    // 5 5 : 1
	for (int i = 0; i < quizNo; i++) {
		int start, end;
		cin >> start >> end;
		cout << S[end]-S[start-1] << "\n";
	}
}
```
## 원리
문제에서 합을 구해야 하는 횟수가 최대 100,000번인데 최악의 경우 100,000번의 반복문을 사용하는 것은 불가피하지만 추가적으로
중첩 반복문을 사용한다면(구간합을 사용하지 않으면 중첩 반복문을 사용해야 함) 시간복잡도가 n^2이 된다. 따라서 0.5초 안에 계산하지 못할 확률이 크므로 시간 복잡도를 n으로 만들기 위해서 구간 합을 사용한다.

1. N개의 수를 입력받음과 동시에 합 배열을 생성한다.  
`S[i]=S[i-1]+A[i]`
2. 구간 i~j가 주어지면 구간 합을 구한다.  
`S[j]-S[i-1]`  

```c++
ios::sync_with_stdio(false);
cin.tie(NULL);
cout.tie(NULL);
```
문제 풀이에서 사용한 위 코드는 시간 단축을 위해서 사용한 것이다. (이 코드가 없으면 실패로 된다.)
`ios::sync_with_stdio(false);`는 C의 stdio와 C++의 iostream의 동기화를 비활성화한다. 따라서 C++ 독립 버퍼 사용으로 수행 속도가 빨라지는
효과가 발생한다.  

`cin.tie(NULL); cout.tie(NULL);`는 하나로 묶인 두 스트림을 푼다. 기본적으로 cin, cout은 하나로 묶였는데, 이것은 한 스트림이 다른 스트림에서 
각 IO작업을 진행하기 전 자동으로 버퍼를 비워주는 것을 보장한다. 특히 cin을 수행하기 전 기본적으로 cout 출력 버퍼를 지우는 작업을 수행하는데, 이 작업을
생략하기 때문에 속도가 빨라지는 효과가 있다. (다만 멀티스레드 환경에서는 사용을 권장하지 않는다.)

# 11660 구간 합 구하기 2
```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int N, M;
	cin >> N >> M;
    // 벡터를 사용한 이유는 N을 받아 동적 배열을 사용해야 하기 때문
    // 벡터를 사용하여 이차원 벡터의 각 요소를 0으로 초기화 
    // A는 기존 이차원 배열(A는 사실 cin >> A[i][j] 이 아니라 cin >> temp로 풀어도 아무 문제가 없다), D는 합 배열
	vector<vector<int>> A(N + 1, vector<int>(N + 1, 0));
	vector<vector<int>> D(N + 1, vector<int>(N + 1, 0));
	for (int i = 1; i <= N; i++)
	{
		for (int j = 1; j <= N; j++)
		{
			cin >> A[i][j];
			// 2차원 구간 합 배열 만들기 - 구간 합 특성상 (3,4),(3,4)처럼 같은 인덱스가 두 번 나와도 계산 가능해야 하므로 합 배열은 인덱스가 1부터 시작해야 한다.
			D[i][j] = D[i][j - 1] + D[i - 1][j] - D[i - 1][j - 1] + A[i][j];
		}
	}

	for (int i = 0; i < M; i++)
	{
		int x1, y1, x2, y2;
		cin >> x1 >> y1 >> x2 >> y2;
		// 구간 합 배열을 사용한 최종 값 계산은 마지막 인덱스로부터 1. 왼쪽 열 뺄셈 2. 상단 행 뺄셈 3. 중복 원소 더하기로 이루어진다.
		int result = D[x2][y2] - D[x1 - 1][y2] - D[x2][y1 - 1] + D[x1 - 1][y1 - 1];
		cout << result << "\n";
	}
}
```
## 원리
기존 이차원 배열을 통해 구간 합 이차원 배열을 만들기 위해 손으로 풀어봐야 하는 문제이다.
기존 이차원 배열에서 어떻게 덧셈 뺄셈을 해야 x,y축으로의 구간 합배열을 만들 수 있는지를 알아야 하기 때문이다.
손으로 풀어보면 기존 이차원 배열에서 어떻게 구간을 지정(영역 간의 덧셈, 뺄셈)해야 구간합을 만들 수 있는지 보일 것이다.
그로부터 아래와 같은 공식이 도출된다.
```c++
// 이차원 구간 합 배열 만들기
D[i][j] = D[i][j - 1] + D[i - 1][j] - D[i - 1][j - 1] + A[i][j];
// 이차원 구간 합 배열로부터 결과값 도출
int result = D[x2][y2] - D[x1 - 1][y2] - D[x2][y1 - 1] + D[x1 - 1][y1 - 1];
```

# 10986 나머지 합 구하기
```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int N, M;
	cin >> N >> M;
	vector<long> S(N, 0);
	vector<long> C(M, 0);
	long answer = 0;
    // 구간 합 구하기 1,2에서는 첫번째 원소에 0을 고정하고 시작했다. 그 이유는 구간 합 배열의 원소끼리 계산을 해야 했기 때문이다.
    // 하지만 이 문제에서는 구간 합 배열의 원소 간의 계산보다는 조합을 이용해서 풀었기 때문에, 첫번째 원소에 0을 고정하지 않아도 되고, 고정하지 않는 방법이 더 쉽다.
	cin >> S[0];
	for (int i = 1; i < N; i++)
	{
		int temp = 0;
		cin >> temp;
		S[i] = S[i - 1] + temp;
	}

	for (int i = 0; i < N; i++) { // 합 배열의 모든 값에 % 연산 수행하기
		int remainder = S[i] % M;
		// 0 ~ i까지의 구간 합 자체가 0일 때 정답에 더하기
		if (remainder == 0) answer++;
		// 나머지가 같은 인덱스의 개수 카운팅하기
		C[remainder]++;
	}
	for (int i = 0; i < M; i++) {
		if (C[i] > 1) {
			// 나머지가 같은 인덱스 중 2개를 뽑는 경우의 수를 더하기
			answer = answer + (C[i] * (C[i] - 1) / 2);
		}
	}
	cout << answer << "\n";
}

```
## 원리
1. (A+B)%C는 ((A%C)+(B%C))%C)와 같다.
2. 구간 합 배열이 S라고 가정하면 (S[j]%M)의 값과 (S[i]%M)의 값이 같다면 (S[j]-S[i])%M은 0이다.

## 풀이
1. 배열 A와 구간 합 배열 S를 생성한다.  
배열 A : {1, 2, 3, 1, 2}  
구간 합 배열 S : {1, 3, 6, 7, 9}
2. 나머지 연산을 수행한 합 배열 S : {1, 0, 0, 1, 0}
3. 값이 0인 원소를 선택하면 M으로 나누어떨어지므로 : +3
4. 값이 0인 원소를 2개 선택하면 연속된 부분의 합을 선택한 것과 같으므로 3C2 : +3
5. 2번 원리를 사용하면, 값이 1인 원소를 2개 선택하면 연속된 부분의 합을 선택한 것과 같으므로 2C2 : +1
6. 모든 경우의 수 : 3 + 3 + 1 =7

## 모듈러 연산
```c++
(A + B) % p = ((A % p) + (B % p)) % p
(A * B) % p = ((A % p) * (B % p)) % p
(A - B) % p = ((A % p) - (B % p) + p) % p
// 나눗셈은 페르마의 소정리 사용
(A / B) % p = (A * B^(p-2)) % p = ((A % p) * (B^(p-2) % p)) % p
```